\documentclass{csse4400}

% \teachermodetrue

\usepackage{float}

\usepackage{languages}
\usepackage{framed}

\title{Application Programming Interfaces (APIs)}
\author{Brae Webb}

\date{\week{1}}
\begin{document}

\maketitle

\begin{figure}[h]
  \href{https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/ch04.html}{
    \includegraphics[width=\textwidth]{images/communication}
  }
\caption{A map of communication techniques from Designing Data-Intensive Applications \cite{data-intensive}.}
\end{figure}

\section{This Week}
This week our goal is to:
\begin{itemize}
  \item explore techniques used by developers use to communicate between components in distributed systems;
  \item initialize our GitHub repositories where we will be working on practical exercises; and
  \item build a minimal HTTP API of a todo app using the Flask framework.
\end{itemize}

\section{Practicals}
These practicals are designed to prepare you with the technical skills required for the cloud and team projects.
We will normally spend the first section of the practicals gaining the relevant conceptual background for the practical.
The second section will be a practical exercise where you will need to write and run some code.

This semester we will be working on the creation of a scalable and fault-tolerant todo application.
You should aim to keep up with the practicals or you will not be able to complete the projects.

\teacher{
    Spend approximately the first 30 minutes exploring the communication techniques listed below.

    Emphasise that in this course we're focusing on large complex systems which are distributed across multiple machines,
    as such we need to be able to communicate between components.
}

\section{Communication}
The world relies (heavily) on distributed systems,
single machines are no longer sufficient to handle the demands of modern applications.
There is no machine in the world powerful enough to process the requests Google receives every second%
\footnote{Current estimates are that Google requires over a million servers}.
But you don't need to be the size of Google to require distributed systems,
even relatively small applications require multiple machines to handle the load.
This inter-machine teamwork requires each machine to know how to talk to the others.

In this practical,
we will be exploring the different techniques used to communicate between components in distributed systems.
We will then build a simple HTTP API using the Flask framework which allows other applications to interact with our application.

\section{Data Formats}
Communication requires an exchange of information.
On single computer systems, information is often stored at runtime in memory as primitive data which your programming language can interpret;
bytes, integers, strings, etc.
In object-oriented languages,
primitive data is wrapped up into useful packages: objects.
If we want this information to escape the confines of our programming language runtime,
we need to package it up in a language-independent format.
To be language-independent we need many languages to implement an encoding and decoding mechanism for the format.
We have several language-independent formats available but a few defacto standards.

\subsection{XML}
Extensible Markup Language (XML) is one of the most widely used language-independent formats.
The use cases of XML are extensive,
it is the \link{foundation for many popular utilities}{https://en.wikipedia.org/wiki/List_of_XML_markup_languages},
such as SVG file formats, SAML authentication, RSS feeds, and ePub books.
\begin{code}[language=xml]{csse6400.xml}
<root>
  <item>
    <key>Course Code</key>
    <value>CSSE6400</value>
  </item>
  <item>
    <key>Course Title</key>
    <value>Software Architecture</value>
  </item>
</root>
\end{code}

XML is designed as a markup language, similar to HTML,
it is not designed as a data exchange format.
Developers have come to point out that the verbosity and complexity of XML,
compared to alternatives such as JSON, are deal breakers.
While XML can be used as a data exchange format it is not designed for it,
and as a result APIs built around XML as a data format are becoming less common.

\subsection{JSON}
JavaScript Object Notation (JSON) is quickly replacing XML as the data format used in APIs.
As you will note, it is more succinct and communicates the important points to a human reader better.
The popularity of JSON is largely due to its compatibility with JavaScript which has taken over as the defacto web development language.
JSON is the map-esque data type in JavaScript.
Detractors of JSON claim that its main disadvantage compared to XML is that it lacks a schema.
However, \link{schemas are possible in JSON}{https://json-schema.org/},
they are optional, just as in XML, but are used much less than in XML.

\begin{code}[language=json]{csse6400.json}
{
    "Course Code": "CSSE6400",
    "Course Title": "Software Architecture"
}
\end{code}

\subsection{MessagePack}
It should not be a surprise that the JSON and XML formats are not resource efficient.
Nowadays, we are less concerned with squeezing data into a tiny amount of data on the hard drive as storage is cheap.
However, we are often concerned with how much data is being transmitted via network communication as bandwidth can be expensive.

In the example JSON snippet above, we use 78 bytes to encode the message.
\link{MessagePack}{https://msgpack.org/} is a standard for encoding and decoding JSON.
When encoding our original JSON snippet with MessagePack we shrink to just 57 bytes.
At our scale, a negligible difference,
but at the scale of terrabytes or petabytes,
a significant factor.

\begin{code}[]{csse6400.msgpack}
82 ab 43 6f 75 72 73 65 20 43 6f 64 65 a8 43 53 53 45 36 34 30 30 ac 43 6f 75 72 73 65 20 54 69 74 6c 65 b5 53 6f 66 74 77 61 72 65 20 41 72 63 68 69 74 65 63 74 75 72 65
\end{code}

\info{
    For those interested,
    0x82 specifies a map type (0x80) with two fields (0x02).
    Followed by a string type (0xa0) of size eleven (0x0b).
    The rest is left as an exercise: \url{https://github.com/msgpack/msgpack/blob/master/spec.md}.
}

\subsection{Protobuf}
Protocol Buffers (protobuf) is another type of binary encoding.
However, unlike MessagePack, the format was designed from scratch,
allowing a more compact and better designed format.
Protobufs require all data to be defined by a schema.
For example:

\begin{code}[language=protobuf]{csse6400.proto}
message Course {
    required string code = 1;
    required string name = 2;
}
\end{code}

Protobufs differ from XML, JSON, and MessagePack via their method of integration.
In the previous examples,
your language would have a library to encode and decode the data format into and out of your language's type system.
With protobuf, an external tool, \textsl{protoc},
takes the schema and generates a model of the schema in your target language.
This gives every language a native interface for interacting with the data format,
often allowing developers to not be aware of the underlying encoding.

\bash{protoc --java\_out=. csse6400.proto}

\begin{code}[language=java]{csse6400.java}
Course softarch = Course.newBuilder()
    .setCode("CSSE6400")
    .setName("Software Architecture")
    .build();
output = new FileOutputStream(args[0]);
softarch.writeTo(output);
\end{code}

\section{API Protocols}
It is worth being aware of a few of the common protocols and conventions used in APIs.
Fortunately, we do not need to understand the low-level communication protocols,
such as TCP/IP, HTTP, and HTTPS,
as these are handled by the underlying libraries.
We will focus on the higher-level protocols and conventions.

We outline a few but note that in this course we will primarily focus on REST APIs.
This is only an indication that they are better understood by course staff,
not their superiority.

\subsection{XML-RPC}
XML-RPC was one of the first API standards.
It is a Remote Procedure Call (RPC) based API which communicates via XML.
It is not a commonly used standard anymore.

\subsection{SOAP}
After XML-RPC came SOAP.
SOAP was impactful for service-oriented (now microservices) architectures but has largely fallen out of favour in-place of REST APIs.
We do not cover SOAP in any meaningful depth due to its increasing irrelevance and complexity.

\subsection{REST}
REST is not a standard like SOAP once was,
instead REST is an architectural style guided by a set of architectural constraints that allows us to build flexible APIs.

In this course we do not dive too deep into the architectural style and instead opt for a more surface level understanding.
It is a common mistake for people to refer to REST as a HTTP based web service API,
they are different.
In this course we chose to embrace this mistake and often refer to a HTTP based web service API when saying REST.

\noindent An example of this type of API might be:
\begin{description}
  \item[GET /api/v1/todo] List all tasks todo
  \item[POST /api/v1/todo] Create a task todo
  \item[GET /api/v1/todo/{id}] List all details about a certain task
  \item[PUT /api/v1/todo/{id}] Update the fields of an existing task
  \item[DELETE /api/v1/todo/{id}] Delete a specific task
\end{description}

\subsection{JSON-RPC}
A JSON RPC is another RPC based API based around communication via JSON.
When deciding whether to use an RPC-based API or a REST/SOAP based API,
the distinction to make is that RPC APIs should be action based, i.e. ``I want to do X''.
Whereas REST/SOAP APIs are Create Read Update Delete (CRUD) based for providing a interface to mutable data.

\subsection{GraphQL}
GraphQL is a query language which allows more dynamic querying of data than REST based APIs.
You can create nested queries and specify the fields you want to receive in response.
GraphQL APIs are well-suited for building APIs designed for developers to consume but when dealing with rigid inter-service based requests,
REST APIs are generally preferable.

\subsection{gRPC}
Another RPC framework, gRPC has started gaining a lot of attention since its first release in 2016.
gRPC is based on the protobuf format.
In addition to a more type-safe system,
gRPC based APIs provide authentication and streaming mechanisms.

\section{GitHub}

We will use GitHub to host our practical work.
This is strongly encouraged as it will help you to get experience with the assessment submission process.
Additionally, committing your work is a good habit to get into and will be useful for your future career.

\subsection{Creating a GitHub Account}
If you do not already have a GitHub account, you will need to create one.
You can do this by visiting \url{https://github.com/join}.

\subsection{Joining the Course Organization}
Once you have created an account, you will need to join the course organization.
If you have not yet filled out the Google Form,
you will need to do so before you can join the organization.
The link to the Google Form can be found on Blackboard.

Once you have filled out the form,
tell your tutor your GitHub username and they will add you to the organization.

\subsection{Joining the GitHub Classroom}
Once you have joined the organization,
you will need to join the GitHub Classroom.

\todo{Add link to GitHub Classroom}

\subsection{Creating a Practical Repository}

\section{TODO}

\subsection{The API design}

\subsubsection{GET /api/v1/health}
This endpoint should return a 200 status code and a JSON object with a single field, \textbf{status}, which should be set to \textbf{ok}.


\begin{code}[language=json,numbers=none]{}
  {
    "status": "ok"
  }
\end{code}

\subsubsection{GET /api/v1/todos}
This endpoint should return a list of all the tasks in the todo list.

Optional query parameters:
\begin{itemize}
\item \textbf{completed} A boolean value indicating whether to return completed tasks or not. Valid values are \texttt{true} or \texttt{false}.
  \item\textbf{window} An integer value indicating how many days past todays date a task should be due by.
\end{itemize}

e.g. \url{http://localhost:6400/api/todos?completed=true&window=7}
\begin{code}[language=json,numbers=none]{}
  [
    {
      "id": 1,
      "title": "Watch CSSE6400 Lecture",
      "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
      "completed": true,
      "deadline_at": "2023-02-27T00:00:00",
      "created_at": "2023-02-20T00:00:00",
      "updated_at": "2023-02-20T00:00:00"
    },
    {
      ...
    },
    ...
  ]
\end{code}

\subsubsection{GET /api/v1/todos/\string{id\string}}
This endpoint should return a single item from the todo list.


\begin{code}[language=json,numbers=none]{}
  {
    "id": 1,
    "title": "Watch CSSE6400 Lecture",
    "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
    "completed": false,
    "deadline_at": "2023-02-27T00:00:00",
    "created_at": "2023-02-20T00:00:00",
    "updated_at": "2023-02-20T00:00:00"
  }
\end{code}

\subsubsection{POST /api/v1/todos}
This endpoint should create a new task in the todo list. The title field must be included in the request and all other values are optional. The \texttt{created\_at}, \texttt{updated\_at} cannot be set by this method.

Attempting to post any other fields than \texttt{title, description, completed, deadline\_at} will cause a 400 error to be returned.


\begin{code}[language=json,numbers=none]{}
  {
    "title": "Watch CSSE6400 Lecture",
    "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
    "completed": false,
    "deadline_at": "2023-02-27T00:00:00",
  }
\end{code}


\begin{code}[language=json,numbers=none]{}
  {
    "id": 1,
    "title": "Watch CSSE6400 Lecture",
    "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
    "completed": false,
    "deadline_at": "2023-02-27T00:00:00",
    "created_at": "2023-02-20T00:00:00",
    "updated_at": "2023-02-20T00:00:00"
  }
\end{code}

\subsubsection{PUT /api/v1/todos/\string{id\string}}
This endpoint should update a task in the todo list. The \texttt{created\_at}, \texttt{updated\_at} cannot be set by this method.

Attempting to post any other fields than \texttt{title, description, completed, deadline\_at} will cause a 400 error to be returned.

\begin{code}[language=json,numbers=none]{}
  {
    "title": "Join the Richard Thomas fan club",
  }
\end{code}

\begin{code}[language=json,numbers=none]{}
  {
    "id": 1,
    "title": "Join the Richard Thomas fan club",
    "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
    "completed": false,
    "deadline_at": "2023-02-27T00:00:00",
    "created_at": "2023-02-20T00:00:00",
    "updated_at": "2023-02-20T00:00:00"
  }
\end{code}

\subsubsection{DELETE /api/v1/todos/\string{id\string}}
This endpoint should delete a task from the todo list. If the task does not exist, a 200 is returned with an empty response.

\begin{code}[language=json,numbers=none]{}
  {
    "id": 1,
    "title": "Join the Richard Thomas fan club",
    "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
    "completed": false,
    "deadline_at": "2023-02-27T00:00:00",
    "created_at": "2023-02-20T00:00:00",
    "updated_at": "2023-02-20T00:00:00"
  }
\end{code}


\subsection{Implementation with Flask}

\subsubsection{Setting up your environment}

The practicals will be using Python as our implementation language but the course is not restricted to Python. Feel free to implement the practicals and your assignments in any language you feel comfortable with but be aware that help with other languages or frameworks may be limited.


\warning{
If you are on Windows, we recommend using a Unix based environment, such as WSL2 or a virtual machine running Ubuntu.
}

\info{
  You will require an installation of Python 3 and pip to be able to complete this practical. Install these tools now before continuing.
}

We will be using `pipenv' to manage the Python libraries we need for this project so let's install that now.

\begin{code}[language=bash,numbers=none]{}
  $ python3 -m pip install pipenv
\end{code}

Navigate to you cloned practical respository in a terminal and start your project by creating the Python environment using the following:

\begin{code}[language=bash,numbers=none]{}
  $ pipenv --python 3
\end{code}

This will create a `Pipfile' and a `Pipfile.lock' file. The Pipfile is where we will specify the libraries we need for our project and the Pipfile.lock is where pipenv will store the versions of the libraries we have installed. We will use the Pipfile to install the libraries we need for the API.

\begin{code}{Pipfile}
  [[source]]
  name = "pypi"
  url = "https://pypi.org/simple"
  verify_ssl = true

  [dev-packages]

  [packages]

  [requires]
  python_version = "3.10"
\end{code}

\info{Your Python version may be different, this is fine as long as it is Python 3.}

Next we are going to add Flask as a dependency to our project. This library is a small web server wrapper that will allow us to quickly build our todo application. To add a dependency to our project, we can run the following command:

\begin{code}[language=bash,numbers=none]{}
  $  pipenv install flask
\end{code}

Once this is done you can see it has made some changes to our Pipfile and Pipfile.lock files.

\subsubsection{Initialising with Flask}

Create a folder called  `todo' in the root of your project and create a file called \texttt{\_\_init\_\_.py} and add the following code to it:

\begin{code}[language=python]{}
  from flask import Flask

  def create_app():
      app = Flask(__name__)
      return app
\end{code}

Your repository should now look like:

\begin{code}[language=bash,numbers=none]{}
  .
  |-- README.md
  |-- Pipfile
  |-- Pipfile.lock
  |-- todo
      |-- __init__.py
\end{code}

We have created a basic Flask app but how do we run it? When using pipenv we need to run it in the following way:

\begin{code}[language=bash,numbers=none]{}
  $ pipenv run flask --app todo run
\end{code}

This web server is a bit boring though, let's add an endpoint so we can see that it works. In the todo folder, create a folder called views and a file \texttt{routes.py}. Add the following code to  \texttt{routes.py}:

\begin{code}[language=python]{}

  from flask import Blueprint

  api = Blueprint('api', __name__, url_prefix='/api/v1')

  @api.route('/health')
  def health():
      return "ok"

\end{code}

The above has made an endpoint within our API under the \texttt{/api/v1} prefix and we have created a \texttt{/health} route below this. Now we need to register this with our flask app. In the \texttt{\_\_init\_\_.py} file, change the contents to the following:

\todo{Change the port to 6400}
\begin{code}[language=python]{}
  from flask import Flask

  def create_app():
      app = Flask(__name__)
      
      from .views.routes import api
      app.register_blueprint(api)
      
      return app

\end{code}

Now when we run the app we should see the following:

\begin{code}[language=bash,numbers=none]{}
  $ pipenv run flask --app todo run

  * Serving Flask app 'todo'
  * Debug mode: off
  WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
  * Running on http://127.0.0.1:6400
  Press CTRL+C to quit
\end{code}

Open your browser and go to http://localhost:6400/api/v1/health and you should see a blank page with "ok" written on it.

If you run into any issues, make sure your files are in the following structure and that you are running these commands in the root folder.

\begin{code}[language=bash,numbers=none]{}
  .
  |-- README.md
  |-- Pipfile
  |-- Pipfile.lock
  |-- todo
      |-- __init__.py
      |-- views
          |-- routes.py
\end{code}

\subsubsection{Returning JSON with Flask}

We have a webserver running now but we are communicating with text instead of a structured format. JSON is a common format to communicate data between services and is human readable. To start using JSON we are going to make a small change to our health endpoint. In the \texttt{routes.py} file, add a new import for jsonify and change the health endpoint to the following:

\begin{code}[language=python]{}
from flask import Blueprint, jsonify
\end{code}

\begin{code}[language=python,firstnumber=6]{}
  @api.route('/health')
  def health():
      return jsonify({"status": "ok"})
\end{code}

Now let's go back to our browser and refresh, we should see the following:

\begin{code}[language=json,numbers=none]{}
  {
    "status": "ok"
  }
\end{code}

\info{If you are using Firefox the json will be parsed and presented in a structured form. To get this for Chrome you can install extensions from the Chrome web store.}

\subsubsection{Calling your API locally}

We have many choices when it comes to calling our API locally. We could use curl, Postman, VS Code, or our browser. We are going to focus on using curl and the REST Visual Studio Code extension.

\vspace{0.5em}
\textbf{curl}

Install curl if it is available for your operating system. If you are on a Mac, you can install it with homebrew otherwise it is available for most Linux distributions.

Now that we have the tool installed let's have our API running in a terminal window and open up a new terminal so we can make requests to our API. Enter in the following into your terminal to call your API.


\begin{code}[language=bash,numbers=none]{}
  $ curl -X GET http://localhost:6400/api/v1/health
\end{code}

You should see the following response:

\begin{code}[language=json,numbers=none]{}
  {
    "status": "ok"
  }
\end{code}

\textbf{VS Code}

If you are using Visual Studio Code for your text editor you can install the ``Rest Client'' by Huachao Mao. This extension allows you to have files with requests that you can then run from  within the editor. The benefit of this method is that we can also check this into our repository.

Find the extension in the VS Code marketplace and install it. Once installed, create a new file in the root of your project called \texttt{endpoints.http} and add the following to it:

\begin{code}[numbers=none]{}
  @baseUrl = http://localhost:6400

  ### Health
  GET {{baseUrl}}/api/v1/health
\end{code}

A subtle "Send Request" should be visible between the comment and the GET. Click on this and a new tab should open up with the response from the API. The response should be similar to below:

\begin{code}[language=json,numbers=none]{}
  HTTP/1.1 200 OK
  Server: Werkzeug/2.2.3 Python/3.10.9
  Date: Sun, 19 Feb 2023 04:13:00 GMT
  Content-Type: application/json
  Content-Length: 16
  Connection: close
    
  {
    "status": "ok"
  }
\end{code}

We can also see in the terminal that our webserver has logged our request by the output of:

\begin{code}[language=bash,numbers=none]{}
  127.0.0.1 - - [19/Feb/2023 14:13:00] "GET /api/health HTTP/1.1" 200 -
\end{code}

\subsubsection{Creating more endpoints}

Let's expand our endpoints.http file to include the other endpoints that we need to create for our todo application. Expand the file to include the following GET, POST, PUT, and DELETE endpoints:

\begin{code}[numbers=none]{}
  @baseUrl = http://localhost:6400

  ### Health
  GET {{baseUrl}}/api/v1/health
  
  ### List All Todos
  GET {{baseUrl}}/api/v1/todos
  
  ### Get a specific Todo
  GET {{baseUrl}}/api/v1/todos/1
  
  ### Create a Todo
  POST {{baseUrl}}/api/v1/todos
  Content-Type: application/json
  
  {
      "title": "An example Todo",
      "description": "This is an example todo",
  }
  
  ### Update a Todo
  PUT {{baseUrl}}/api/v1/todos/1
  Content-Type: application/json
  
  {
      "title": "updated title",
  }
  
  ### Delete a Todo
  DELETE {{baseUrl}}/api/v1/todos/1
  
\end{code}

Let's run the GET request and see what happens. We should see the following:

\begin{code}[language=html,numbers=none]{}
  HTTP/1.1 404 NOT FOUND
  Server: Werkzeug/2.2.3 Python/3.10.9
  Date: Sun, 19 Feb 2023 04:27:42 GMT
  Content-Type: text/html; charset=utf-8
  Content-Length: 207
  Connection: close
  
  <!doctype html>
  <html lang=en>
  <title>404 Not Found</title>
  <h1>Not Found</h1>
  <p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>  
\end{code}

Now we can start to create the endpoints that we need for our todo application. In the \texttt{routes.py} file, add the following code to the bottom of the file:

\begin{code}[language=python]{}
  @api.route('/todos', methods=['GET'])
  def get_todos():
      return jsonify([])
\end{code}

Now the server should reload, if it does not, you can manually reload it by stopping the process and restarting it. Now if we run the GET request again we should see the following:

\begin{code}[language=json,numbers=none]{}
  HTTP/1.1 200 OK
  Server: Werkzeug/2.2.3 Python/3.10.9
  Date: Sun, 19 Feb 2023 04:38:44 GMT
  Content-Type: application/json
  Content-Length: 3
  Connection: close
  
  []
\end{code}

This endpoint is for listing all the todos that the user has. For now we are going to return a hard coded todo item so we can get used to having the API return data. In the \texttt{routes.py} file, modify the \texttt{get\_todos} function to return a hard coded todo item:

\begin{code}[language=python]{}
  @api.route('/todos', methods=['GET'])
  def get_todos():
      return jsonify([{
        "id": 1,
        "title": "Watch CSSE6400 Lecture",
        "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
        "completed": false,
        "deadline_at": "2023-02-27T00:00:00",
        "created_at": "2023-02-20T00:00:00",
        "updated_at": "2023-02-20T00:00:00"
      }])
\end{code}

Now let's run the GET request again and we should see the following:

\begin{code}[language=json,numbers=none]{}
  HTTP/1.1 200 OK
  Server: Werkzeug/2.2.3 Python/3.10.9
  Date: Sun, 19 Feb 2023 04:44:00 GMT
  Content-Type: application/json
  Content-Length: 200
  Connection: close
  
  [
    {
      "id": 1,
      "title": "Watch CSSE6400 Lecture",
      "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
      "completed": false,
      "deadline_at": "2023-02-27T00:00:00",
      "created_at": "2023-02-20T00:00:00",
      "updated_at": "2023-02-20T00:00:00"
    }
  ]
\end{code}

Next is our endpoint to get an individual todo by its id. In the \texttt{routes.py} file, add the following code to the bottom of the file:

\begin{code}[language=python]{}
  @api.route('/todos/<int:id>', methods=['GET'])
  def get_todo(id):
      return jsonify({
        "id": id,
        "title": "Watch CSSE6400 Lecture",
        "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
        "completed": false,
        "deadline_at": "2023-02-27T00:00:00",
        "created_at": "2023-02-20T00:00:00",
        "updated_at": "2023-02-20T00:00:00"
      })
\end{code}

You will notice in this function we have a single parameter which is the ID fetched from the URL. You can see this in the \texttt{<int:id>} part of the route annotation. This is a Flask feature that allows you to fetch parameters from the URL. 

These were our read only methods, now let's get to the mutating methods. First is our endpoint to create a new todo. In the \texttt{routes.py} file, add the following code to the bottom of the file:

\begin{code}[language=python]{}
  @api.route('/todos', methods=['POST'])
  def create_todo():
      return jsonify({
        "id": 1,
        "title": "Watch CSSE6400 Lecture",
        "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
        "completed": false,
        "deadline_at": "2023-02-27T00:00:00",
        "created_at": "2023-02-20T00:00:00",
        "updated_at": "2023-02-20T00:00:00"
      })
\end{code}

You will notice that currently this function is the same as the GET request but in future weeks we will build out the functionality to actually create a todo. Next is our endpoint to update a todo. In the \texttt{routes.py} file, add the following code to the bottom of the file:

\begin{code}[language=python]{}
  @api.route('/todos/<int:id>', methods=['PUT'])
  def update_todo(id):
      return jsonify({
        "id": id,
        "title": "Watch CSSE6400 Lecture",
        "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
        "completed": false,
        "deadline_at": "2023-02-27T00:00:00",
        "created_at": "2023-02-20T00:00:00",
        "updated_at": "2023-02-20T00:00:00"
      })
\end{code}

Likewise with the POST request, this function is the same as the GET request but in future weeks we will build out the functionality to actually update a todo. Finally is our endpoint to delete a todo. In the \texttt{routes.py} file, add the following code to the bottom of the file:

\begin{code}[language=python]{}
  @api.route('/todos/<int:id>', methods=['DELETE'])
  def delete_todo(id):
      return jsonify({
        "id": id,
        "title": "Watch CSSE6400 Lecture",
        "description": "Watch the CSSE6400 lecture on ECHO360 for week 1",
        "completed": false,
        "deadline_at": "2023-02-27T00:00:00",
        "created_at": "2023-02-20T00:00:00",
        "updated_at": "2023-02-20T00:00:00"
      })
\end{code}

Likewise with the POST request, this function is the same as the GET request but in future weeks we will build out the functionality to actually delete a todo.

With the endpoints you may have noticed us defining the methods, this is because we want to define which HTTP methods are allowed for each endpoint. For example, we do not want a user to be able to delete a todo by sending a GET request, we want them to send a DELETE request.

This concludes this week's practical. Next week we will add storage to our API so that we can actually create, update and delete todos. We will also add some tests to our API to ensure that it is working as expected and meets our specification. The final files you should have for this practical are available at \url{github.com/csse6400/?}. Remember to ask for any assistance on the Slack channel if you get stuck or have any questions.

\todo{Fill in the github link that is above.}

\bibliographystyle{ieeetr}
\bibliography{books,ours}

\end{document}
