\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\newcommand{\thetitle}{\textsl{Lit}erate Programming}

\usepackage[a4paper, total={6in, 10in}]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyfoot[R]{\thepage}
\fancyfoot[L]{\thetitle}

\usepackage{xcolor}

\title{\thetitle}
\author{Brae Webb}
\date{Semester 1, 2022}

\begin{document}
\maketitle

\begin{abstract}
In {\color{red} 1900}, Donald Knuth coined the term \textsl{literate programming}.
Literate programming proposes a paradigm shift wherein programmers are akin to authors,
and programs akin to books.
To successfully make the shift, programs and their documentation must be interleaved.
We propose \textsl{lit}, an \textbf{extensible} tool to transform software repositories into books.
\end{abstract}

\section{Functionality}
To be successful, the tool must be able to produce a book given a software repository.
This will involve invoking a command line application at the root level of the repository.
The tool will then;
\begin{itemize}
    \item determine any metadata (i.e. title, authors, abstract, etc),
    \item collect any documentation files (i.e. README.md, LICENSE, etc),
    \item parse source code and interleave documentation with code,
    \item detect any build systems present,
    \item describe the build workflow, and finally
    \item collate all the collected information into an organised book.
\end{itemize}

Due to the variety of languages and tools used in any software repository,
the implicit scope of the above tasks is massive.
Our base functionality will include (i) the kernal to orchastrate the collation of a document
and (ii) support for the following popular tools as a proof-of-concept.
\begin{itemize}
    \item Common README formats, including {\color{red} standard}, LICENSE, CONTRIBUTING, etc.
    \item Java and Javadoc support.
    \item Python and docstring support.
    \item Github actions workflow support.
\end{itemize}

\section{Architecture}

\section{Evaluation}
The success of our project will be determined by having a sufficiently extensible kernal.
To evaluate the extensibility, we will use quantatative and qualitative assessment.
During development, we will monitor various quantatative metrics outlined in Section \ref{sect:metrics}.
After development, we will perform qualitative testing asking others to attempt implementing a new extension for the tool. Our approach to performing this evaluation is outlined in Section \ref{sect:study}.

\subsection{Metrics}\label{sect:metrics}
The metrics most relevant to extensibility are:
\begin{itemize}
    \item amount of duplicated code between components;
    \item amount of boilerplate code; and
    \item overall component size.
\end{itemize}

During the development of the project, we will monitor these metrics semi-automatedly.
They will act as indications on whether refactorings of the kernal impacts positive change towards extensibility.

\subsection{Developer Study}\label{sect:study}
Once the kernal development has stablized, we will conduct a study amoung our collegues.
We will setup a typical extension development environment and ask them to implement a new extension for their prefered language or build system.
They will have 30 minutes to attempt to implement the extension.
After 30 minutes, we will prompt them with a survey.
The survey will include general evaluation metrics of interest as well as free-form feedback.
If they choose to continue implementing, we will provide a separate survey for providing long-term feedback.

\end{document}