\title{Software Architecture}

\maketitle

\section{Introduction}
An introduction to Software Architecture would be incomplete without the requisite
exploration into the term `software architecture'.
The term is often overloaded to describe a number of completely detached concepts.
The overloaded nature of the term makes an introduction quite challenging.
Martin Fowler wrestles with this difficultly in his talk on \link{``Making Architecture Matter''}{https://www.youtube.com/watch?v=DngAZyWMGR0}.
In the talk Fowler settles on the slightly vague definition from Ralph Johnson \cite{fowler-what-is-architecture}:

\begin{definition}[Software Architecture]
The important stuff; whatever that is.
\end{definition}

In this course, we will try to narrow the scope slightly.
We need a definition which encompasses the numerous practical strategies which you need to survive and thrive in industry life.
This definition should not be attributed to the term `Software Architecture'; that term is much too broad to define succinctly.
This is purely the definition used to provide an appropriate scope for the course.

\begin{definition}[Software Architecture: The Course]
The set of tools, processes, and design patterns which enable me to deliver high quality software
\end{definition}

\section{High Quality Software}
We assume that as software engineers you wish to deliver high quality software systems.
The issue is that ``quality'', like ``beauty,'' is in the eye of the beholder.
As a diligent and enthusiastic software engineer, you may think that ``high quality'' means well designed software with few defects.
On the other hand, your users may think that ``high quality'' means an engaging user experience, with no defects.
While your project sponsor, who is funding the project, may think that ``high quality'' means the software includes all the features they requested.
Rarely is there enough time and money available to deliver everything to the highest standard.
The development team has to balance competing expectations and priorities to develop a software system that is a good compromise and meets its key goals.

From the perspective of designing a software architecture, competing expectations provides what are sometimes called \textit{architectural drivers}.

\subsection{Functional Requirements}
A seemingly obvious driver is the functional requirements for the software system, i.e. what the software should do.
If you do not know what the software is meant to do, how can you design it?
You do not need an extensive and in-depth description of every small feature of the software,
but you do need to know what problem the software is meant to solve, who are the key users,
and what are the key features of the software.
Without this information, you do not know what style of architecture is going to be appropriate for the software system.

For example, consider an application that allows users to write and save notes with embedded images and videos.
Say the decision was made to implement it as a simple mobile app that saves notes locally.
If it is then decided that web and desktop applications are needed, allowing users to sync their notes across applications and share notes with others,
the application will need to be redesigned from scratch.
Knowing up-front that the software needed to support multiple platforms, and that syncing and sharing notes was important, 
would have allowed the developers to design a software architecture that would support this from the start.\footnote{This is different to building a quick-and-dirty prototype
to explore options. That is a valid design process, and in that case minimal effort will be put into creating a well-designed app.}

\subsection{Constraints}
Constraints are external factors that are imposed on the development project.
Commonly, these are imposed by the organisation for whom you are building the software system.
The most obvious constraint is time and budget. A sophisticated software architecture will take more
time, and consume more of the total budget, than a simple but less flexible architecture.

Other common constraints are technology, people and the organisation's environment.
Technology constraints are one of the most common set of constraints that affect the design of the architecture.
Even if it is a ``greenfields'' project\footnote{This refers to the idea that it is a new project and is not limited by
needing to conform to existing system's or expectations.}
there will usually be restrictions on choices of technology that may or may not be used.
For example, if all of the organisation's existing applications are running on the Google cloud platform,
there will probably be a restriction requiring all new applications to be built on the same platform
to avoid the overheads of working with different cloud providers.

People constraints takes into consideration the skills that are available within the organisation and the availability of developers for the project.
Designing an architecture that requires skills that are not available, will add an overhead to the project's development cost.
If contractors can be hired, or training is available, these may reduce the overhead but the decision needs to be made based on the risks and benefits.

The organisation's environment may influence other constraints, or add new constraints.
An organisation that encourages innovation may be flexible in allowing some technology constraints to be broken.
If the project is of strategic value to the business, there may be options to negotiate for a larger budget or to adopt
a new technology, if they could lead to a more robust solution with a longer lifespan.
Politics can introduce constraints on architectural choices.
If there is an influential group who promote a particular architectural style, it may be difficult or impossible to make different choices.

\subsection{Principles}
Principles are self-imposed approaches to designing the software.
Typically these are standards that all developers are expected to follow to try to ensure the overall software design is consistent.
From a programming perspective, coding standards and test coverage goals are examples of principles that all developers are expected to follow.
Architectural principles typically relate to how the software should be structured and how design decisions should be made to work well with the software architecture.
Consequently, principles usually do not influence the architecture\footnote{The exception to this is if some principles are constraints enforced by the organisation.},
rather the architecture will influence which principles should be prioritised during software design.

As an example, if the software architecture is designed to be scalable to accommodate peaks in load,
then an architectural principle might be that software components should be stateless to allow them to be easily replicated to share the load.
Another principle might be that an architecture that relies on an underlying object model, will adopt the SOLID design principles \cite{martin-principles-patterns}.

\subsection{Quality Attributes}
While the functional requirements specify what the software should do,
non-functional requirements specify properties required for the project to be successful.
These non-functional requirements are also termed \emph{quality attributes}.

Often quality attributes are specified by phrases ending in -ility.
Medical software needs \textit{reliability}.
Social media needs \textit{availability}.
Census software needs \textit{scalability}.

Below is a collection of non-exhaustive quality attributes to help give you an idea of what we will be looking at in this course.

\begin{description}
    \item[Modularity] Components of the software are separated into discrete modules.
    \item[Availability] The software is available to access by end users, either at any time or on any platform, or both.
    \item[Scalability] The software is simultaneously usable by a large amount of end users.
    \item[Extensibility] Features or extensions can be easily added to the base software.
    \item[Testibility] The software is designed so that automated tests can be easily deployed.
\end{description}

Quality attributes are one of the main focuses of a software architect.
Quality attributes are achieved through architecture designed to support them.
Likewise, software architecture quality and consistency is achieved by principles put in place by a software architect and the development team.

Architects are responsible for identifying the important attributes for their project
and implementing architecture and principles which satisfies the desired attributes.

\section{Attributes in Tension}
One of the defining characteristics of quality attributes is that they are often in conflict with each other.
It is a valiant yet wholly impractical pursuit to construct software which meets all quality attributes.

The role of a software architect is to identify which quality attributes are crucial to the success of their project,
and to design an architecture and implement principles which ensure the quality attributes are achieved.

The first law of software architecture as defined by Richards \cite{richards2020fundamentals} reflects the difficultly in supporting multiple quality attributes.

\begin{definition}[The First Law of Software Architecture]
Everything in software architecture is a trade-off.
\end{definition}

Galster and Angelov \cite{wicked-architecture} define this as `wicked architecture'.
They identify the `wicked' nature of architecture as the main difficultly in teaching the subject.

\begin{definition}[Wicked Architecture]
There are often no clear problem descriptions, no clear solutions, good or bad solutions, no clear rules when to ``stop'' architecting
and mostly team rather than individual work.
\end{definition}

They stress that ``In contrast, other software engineering topics such as programming lead to solutions that can be checked and measured for correctness.
Architecture may be the worst-case scenario when it comes to fuzziness in software engineering''.

Despite this difficultly, in this course we intend to expose you to a number of case studies, architectures,
and tools which aim to give you experience in tackling the trade-offs involved in software architecture.

\section{The World Today}
Software architecture today is more important than ever.
The importance of architecture can be considered a result of \textsl{expectations} and \textsl{infrastructure}.
Today we expect our software to be available 24/7.
To exemplify this point, in October last year Facebook went offline for 6-7 hours out of the 8760 hours of the year.
Those 6-7 hours of downtime resulted in mass media coverage, \$60 million loss of revenue,
and a 5\% drop in company shares which caused Zuckerberg's wealth alone to drop \$6 billion.
Interestingly, the outage also caused other sites such as Gmail, TikTok, and Snapchat to slowdown.

This is a massive change in public expectations for software availability.
Just \todo{when was this} years ago,
human resources at UQ would monopolise the university's computing resources for a day each month to calculate the payroll.
Nowadays that lack of availability from even the university's software systems would be completely unacceptable.
The change in expectations has forced developers to adapt by designing architectures capable of supporting this heightened up-time.

In addition to shifting expectations, developers now have access to a range of Infrastructure as a Service (IaaS) platforms.
IaaS empowers developers to quickly and programmatically create and manage computing, networking, and storage resources.
In part, this enables individual developers to support up-times comparable to tech giants.
Of course, to be able to support these up-times software has increased in overall complexity.
A website is now commonly spread over multiple servers, marking a change from centralised systems to distributed systems.

\todo{End}
