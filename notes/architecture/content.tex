\title{Software Architecture}

\maketitle

\section{Introduction}
An introduction to Software Architecture would be incomplete without the requisite
exploration into the term `software architecture'.
The term is often overloaded to describe a number of completely detached concepts.
The overloaded nature of the term makes an introduction quite challenging.
Martin Fowler wrestles with this difficultly in his talk on ``Making Architecture Matter''.\footnote{\url{https://www.youtube.com/watch?v=DngAZyWMGR0}}
In the talk Fowler settles on the slightly vague definition from Ralph Johnson:

\begin{definition}[Software Architecture]
The important stuff; whatever that is.
\end{definition}

In this course, we will try to narrow the scope slightly.
We need a definition which encompasses the numerous practical strategies which you need to survive and thrive in industry life.
This definition should not be attributed to the term `Software Architecture'; that term is much too broad to define succinctly.
This is purely the definition used to provide an appropriate scope for the course.

\begin{definition}[Software Architecture: The Course]
The set of tools, processes, and design patterns which enable quality attributes to be met in software.
\end{definition}

\section{Quality Attributes}
Software requirements are defined by their functional and non-functional requirements.
The functional requirements specify what the software should do, this is the usual requirements of software.
On the other hand, non-functional requirements specify properties required for the project to be successful.
Non-functional requirements are called Quality Attributes.

Often quality attributes are specified by phrases ending in -ility.
Medical software needs reliability.
Social media needs availability.
Census software needs scalability.

Below is a collection of non-exhaustive quality attributes to help give you an idea of what we'll be looking at in this course.

\begin{description}
    \item[Modularity] Components of the software are separated into discrete modules.
    \item[Availability] The software is available to access by end users, either at any time or on any platform, or both.
    \item[Scalability] The software is simultanoisly usable by a large amount of end users.
    \item[Extensibility] Features or extensions can be easily added to the base software.
    \item[Testibility] The software is designed so that automated tests can be easily deployed.
\end{description}

Quality attributes are one of the main focuses of a software architect.
Quality attributes are achieved through architecture designed to support them.
Likewise, software architecture is achieved by policies put in place by a software architect.

Architects are responsible for identifying the important attributes for their project
and implementing architecture and policies which satisfies the desired attributes.

\section{Attributes in Tension}
One of the defining characteristics of quality attributes is that they are often in conflict with each other.
It is a valiant yet wholly impractical pursuit to construct software which meets all quality attributes.

The role of a software architect is to identify which quality attributes are crucial to the success of their project,
and to implement practices which ensure the quality attribute is achieved.

The first law of software architecture as defined by Richards \cite{richards2020fundamentals} reflects the difficultly in supporting multiple quality attributes.

\begin{definition}[The First Law of Software Architecture]
Everything in software architecture is a trade-off.
\end{definition}

Galster and Angelov \cite{wicked-architecture} define this as `wicked architecture'.
They identify the `wicked' nature of architecture as the main difficultly in teaching the subject.

\begin{definition}[Wicked Architecture]
There are often no clear problem descriptions, no clear solutions, good or bad solutions, no clear rules when to ``stop'' architecting
and mostly team rather than individual work.
\end{definition}

They stress that ``In contrast, other software engineering topics such as programming lead to solutions that can be checked and measured for correctness.
Architecture may be the worst-case scenario when it comes to fuzziness in software engineering''.

Despite this difficultly, in this course we intend to expose you to a number of case studies, architectures, and tools which aim to give you experience in tackling architectural programs.

\section{The World Today}
Software architecture today is more important than ever.
The importance of architecture is primarily the result of \textsl{expectations} and \textsl{infrastructure}.
Today we expect our software to be available 24/7.
To exemplify this point, in October last year Facebook went offline for 6-7 hours out of the 8760 hours of the year.
Those 6-7 hours of downtime resulted in mass media coverage, \$60 million loss of revenue,
and a 5\% drop in company shares which caused Zuckerberg's wealth alone to drop \$6 billion.
Interestingly, the outage also resulted in other sites such as Gmail, TikTok, and Snapchat to slow.

This is a massive change in public expectations for software availability.
Just \todo{when was this} years ago,
human resources at UQ would monopolize the universities computing resources for a day each month to calculate the payroll.
Nowadays that lack of availabilities from even the universities software systems would be completely unacceptable.
The change in expectations has forced developers to adapt by designing architectures capable of supporting this threshold of uptime.

In addition to shifting expectations, developers now have access to a range of Infrastructure as a Service (IaaS) services.
IaaS empowers developers to quickly and programmatically create and manage computing, networking, and storage resources.
This enables developers to support uptimes comparable to tech giants.
Of course, to be able to support these uptimes software has increased in overall complexity.
A website is now commonly spread over multiple servers, marking a change from centralized systems to distributed systems.

\todo{End}
